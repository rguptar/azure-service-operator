// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20180801

import (
	"fmt"
	v20180801s "github.com/Azure/azure-service-operator/v2/api/network/v1beta20180801storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/stable/2018-08-01/trafficmanager.json
// - ARM URI:
type Trafficmanagerprofile struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Trafficmanagerprofile_Spec   `json:"spec,omitempty"`
	Status            Trafficmanagerprofile_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Trafficmanagerprofile{}

// GetConditions returns the conditions of the resource
func (trafficmanagerprofile *Trafficmanagerprofile) GetConditions() conditions.Conditions {
	return trafficmanagerprofile.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (trafficmanagerprofile *Trafficmanagerprofile) SetConditions(conditions conditions.Conditions) {
	trafficmanagerprofile.Status.Conditions = conditions
}

var _ conversion.Convertible = &Trafficmanagerprofile{}

// ConvertFrom populates our Trafficmanagerprofile from the provided hub Trafficmanagerprofile
func (trafficmanagerprofile *Trafficmanagerprofile) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20180801s.Trafficmanagerprofile)
	if !ok {
		return fmt.Errorf("expected network/v1beta20180801storage/Trafficmanagerprofile but received %T instead", hub)
	}

	return trafficmanagerprofile.AssignProperties_From_Trafficmanagerprofile(source)
}

// ConvertTo populates the provided hub Trafficmanagerprofile from our Trafficmanagerprofile
func (trafficmanagerprofile *Trafficmanagerprofile) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20180801s.Trafficmanagerprofile)
	if !ok {
		return fmt.Errorf("expected network/v1beta20180801storage/Trafficmanagerprofile but received %T instead", hub)
	}

	return trafficmanagerprofile.AssignProperties_To_Trafficmanagerprofile(destination)
}

// +kubebuilder:webhook:path=/mutate-network-azure-com-v1beta20180801-trafficmanagerprofile,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=trafficmanagerprofiles,verbs=create;update,versions=v1beta20180801,name=default.v1beta20180801.trafficmanagerprofiles.network.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &Trafficmanagerprofile{}

// Default applies defaults to the Trafficmanagerprofile resource
func (trafficmanagerprofile *Trafficmanagerprofile) Default() {
	trafficmanagerprofile.defaultImpl()
	var temp interface{} = trafficmanagerprofile
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (trafficmanagerprofile *Trafficmanagerprofile) defaultAzureName() {
	if trafficmanagerprofile.Spec.AzureName == "" {
		trafficmanagerprofile.Spec.AzureName = trafficmanagerprofile.Name
	}
}

// defaultImpl applies the code generated defaults to the Trafficmanagerprofile resource
func (trafficmanagerprofile *Trafficmanagerprofile) defaultImpl() {
	trafficmanagerprofile.defaultAzureName()
}

var _ genruntime.KubernetesResource = &Trafficmanagerprofile{}

// AzureName returns the Azure name of the resource
func (trafficmanagerprofile *Trafficmanagerprofile) AzureName() string {
	return trafficmanagerprofile.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2018-08-01"
func (trafficmanagerprofile Trafficmanagerprofile) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (trafficmanagerprofile *Trafficmanagerprofile) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeTenant
}

// GetSpec returns the specification of this resource
func (trafficmanagerprofile *Trafficmanagerprofile) GetSpec() genruntime.ConvertibleSpec {
	return &trafficmanagerprofile.Spec
}

// GetStatus returns the status of this resource
func (trafficmanagerprofile *Trafficmanagerprofile) GetStatus() genruntime.ConvertibleStatus {
	return &trafficmanagerprofile.Status
}

// GetType returns the ARM Type of the resource. This is always ""
func (trafficmanagerprofile *Trafficmanagerprofile) GetType() string {
	return ""
}

// NewEmptyStatus returns a new empty (blank) status
func (trafficmanagerprofile *Trafficmanagerprofile) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Trafficmanagerprofile_STATUS{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (trafficmanagerprofile *Trafficmanagerprofile) Owner() *genruntime.ResourceReference {
	return nil
}

// SetStatus sets the status of this resource
func (trafficmanagerprofile *Trafficmanagerprofile) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Trafficmanagerprofile_STATUS); ok {
		trafficmanagerprofile.Status = *st
		return nil
	}

	// Convert status to required version
	var st Trafficmanagerprofile_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	trafficmanagerprofile.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-azure-com-v1beta20180801-trafficmanagerprofile,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=trafficmanagerprofiles,verbs=create;update,versions=v1beta20180801,name=validate.v1beta20180801.trafficmanagerprofiles.network.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &Trafficmanagerprofile{}

// ValidateCreate validates the creation of the resource
func (trafficmanagerprofile *Trafficmanagerprofile) ValidateCreate() error {
	validations := trafficmanagerprofile.createValidations()
	var temp interface{} = trafficmanagerprofile
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (trafficmanagerprofile *Trafficmanagerprofile) ValidateDelete() error {
	validations := trafficmanagerprofile.deleteValidations()
	var temp interface{} = trafficmanagerprofile
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (trafficmanagerprofile *Trafficmanagerprofile) ValidateUpdate(old runtime.Object) error {
	validations := trafficmanagerprofile.updateValidations()
	var temp interface{} = trafficmanagerprofile
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (trafficmanagerprofile *Trafficmanagerprofile) createValidations() []func() error {
	return []func() error{trafficmanagerprofile.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (trafficmanagerprofile *Trafficmanagerprofile) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (trafficmanagerprofile *Trafficmanagerprofile) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return trafficmanagerprofile.validateResourceReferences()
		},
		trafficmanagerprofile.validateWriteOnceProperties}
}

// validateResourceReferences validates all resource references
func (trafficmanagerprofile *Trafficmanagerprofile) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&trafficmanagerprofile.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (trafficmanagerprofile *Trafficmanagerprofile) validateWriteOnceProperties(old runtime.Object) error {
	oldObj, ok := old.(*Trafficmanagerprofile)
	if !ok {
		return nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, trafficmanagerprofile)
}

// AssignProperties_From_Trafficmanagerprofile populates our Trafficmanagerprofile from the provided source Trafficmanagerprofile
func (trafficmanagerprofile *Trafficmanagerprofile) AssignProperties_From_Trafficmanagerprofile(source *v20180801s.Trafficmanagerprofile) error {

	// ObjectMeta
	trafficmanagerprofile.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Trafficmanagerprofile_Spec
	err := spec.AssignProperties_From_Trafficmanagerprofile_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Trafficmanagerprofile_Spec() to populate field Spec")
	}
	trafficmanagerprofile.Spec = spec

	// Status
	var status Trafficmanagerprofile_STATUS
	err = status.AssignProperties_From_Trafficmanagerprofile_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Trafficmanagerprofile_STATUS() to populate field Status")
	}
	trafficmanagerprofile.Status = status

	// No error
	return nil
}

// AssignProperties_To_Trafficmanagerprofile populates the provided destination Trafficmanagerprofile from our Trafficmanagerprofile
func (trafficmanagerprofile *Trafficmanagerprofile) AssignProperties_To_Trafficmanagerprofile(destination *v20180801s.Trafficmanagerprofile) error {

	// ObjectMeta
	destination.ObjectMeta = *trafficmanagerprofile.ObjectMeta.DeepCopy()

	// Spec
	var spec v20180801s.Trafficmanagerprofile_Spec
	err := trafficmanagerprofile.Spec.AssignProperties_To_Trafficmanagerprofile_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Trafficmanagerprofile_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20180801s.Trafficmanagerprofile_STATUS
	err = trafficmanagerprofile.Status.AssignProperties_To_Trafficmanagerprofile_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Trafficmanagerprofile_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (trafficmanagerprofile *Trafficmanagerprofile) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: trafficmanagerprofile.Spec.OriginalVersion(),
		Kind:    "Trafficmanagerprofile",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/stable/2018-08-01/trafficmanager.json
// - ARM URI:
type TrafficmanagerprofileList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Trafficmanagerprofile `json:"items"`
}

// +kubebuilder:validation:Enum={"2018-08-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2018-08-01")

type Trafficmanagerprofile_Spec struct {
	// AllowedEndpointRecordTypes: The list of allowed endpoint record types.
	AllowedEndpointRecordTypes []AllowedEndpointRecordType `json:"allowedEndpointRecordTypes,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// DnsConfig: The DNS settings of the Traffic Manager profile.
	DnsConfig *DnsConfig `json:"dnsConfig,omitempty"`

	// Endpoints: The list of endpoints in the Traffic Manager profile.
	Endpoints []Endpoint `json:"endpoints,omitempty"`

	// Location: The Azure Region where the resource lives
	Location *string `json:"location,omitempty"`

	// MaxReturn: Maximum number of endpoints to be returned for MultiValue routing type.
	MaxReturn *int `json:"maxReturn,omitempty"`

	// MonitorConfig: The endpoint monitoring settings of the Traffic Manager profile.
	MonitorConfig *MonitorConfig `json:"monitorConfig,omitempty"`

	// ProfileStatus: The status of the Traffic Manager profile.
	ProfileStatus *ProfileProperties_ProfileStatus `json:"profileStatus,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TrafficRoutingMethod: The traffic routing method of the Traffic Manager profile.
	TrafficRoutingMethod *ProfileProperties_TrafficRoutingMethod `json:"trafficRoutingMethod,omitempty"`

	// TrafficViewEnrollmentStatus: Indicates whether Traffic View is 'Enabled' or 'Disabled' for the Traffic Manager profile.
	// Null, indicates 'Disabled'. Enabling this feature will increase the cost of the Traffic Manage profile.
	TrafficViewEnrollmentStatus *ProfileProperties_TrafficViewEnrollmentStatus `json:"trafficViewEnrollmentStatus,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &Trafficmanagerprofile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trafficmanagerprofile *Trafficmanagerprofile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trafficmanagerprofile == nil {
		return nil, nil
	}
	result := &Trafficmanagerprofile_Spec_ARM{}

	// Set property ‘Location’:
	if trafficmanagerprofile.Location != nil {
		location := *trafficmanagerprofile.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if trafficmanagerprofile.AllowedEndpointRecordTypes != nil ||
		trafficmanagerprofile.DnsConfig != nil ||
		trafficmanagerprofile.Endpoints != nil ||
		trafficmanagerprofile.MaxReturn != nil ||
		trafficmanagerprofile.MonitorConfig != nil ||
		trafficmanagerprofile.ProfileStatus != nil ||
		trafficmanagerprofile.TrafficRoutingMethod != nil ||
		trafficmanagerprofile.TrafficViewEnrollmentStatus != nil {
		result.Properties = &ProfileProperties_ARM{}
	}
	for _, item := range trafficmanagerprofile.AllowedEndpointRecordTypes {
		result.Properties.AllowedEndpointRecordTypes = append(result.Properties.AllowedEndpointRecordTypes, item)
	}
	if trafficmanagerprofile.DnsConfig != nil {
		dnsConfig_ARM, err := (*trafficmanagerprofile.DnsConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsConfig := *dnsConfig_ARM.(*DnsConfig_ARM)
		result.Properties.DnsConfig = &dnsConfig
	}
	for _, item := range trafficmanagerprofile.Endpoints {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Endpoints = append(result.Properties.Endpoints, *item_ARM.(*Endpoint_ARM))
	}
	if trafficmanagerprofile.MaxReturn != nil {
		maxReturn := *trafficmanagerprofile.MaxReturn
		result.Properties.MaxReturn = &maxReturn
	}
	if trafficmanagerprofile.MonitorConfig != nil {
		monitorConfig_ARM, err := (*trafficmanagerprofile.MonitorConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		monitorConfig := *monitorConfig_ARM.(*MonitorConfig_ARM)
		result.Properties.MonitorConfig = &monitorConfig
	}
	if trafficmanagerprofile.ProfileStatus != nil {
		profileStatus := *trafficmanagerprofile.ProfileStatus
		result.Properties.ProfileStatus = &profileStatus
	}
	if trafficmanagerprofile.TrafficRoutingMethod != nil {
		trafficRoutingMethod := *trafficmanagerprofile.TrafficRoutingMethod
		result.Properties.TrafficRoutingMethod = &trafficRoutingMethod
	}
	if trafficmanagerprofile.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := *trafficmanagerprofile.TrafficViewEnrollmentStatus
		result.Properties.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
	}

	// Set property ‘Tags’:
	if trafficmanagerprofile.Tags != nil {
		result.Tags = make(map[string]string, len(trafficmanagerprofile.Tags))
		for key, value := range trafficmanagerprofile.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if trafficmanagerprofile.Type != nil {
		typeVar := *trafficmanagerprofile.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trafficmanagerprofile *Trafficmanagerprofile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Trafficmanagerprofile_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trafficmanagerprofile *Trafficmanagerprofile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Trafficmanagerprofile_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Trafficmanagerprofile_Spec_ARM, got %T", armInput)
	}

	// Set property ‘AllowedEndpointRecordTypes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AllowedEndpointRecordTypes {
			trafficmanagerprofile.AllowedEndpointRecordTypes = append(trafficmanagerprofile.AllowedEndpointRecordTypes, item)
		}
	}

	// Set property ‘AzureName’:
	trafficmanagerprofile.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘DnsConfig’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsConfig != nil {
			var dnsConfig1 DnsConfig
			err := dnsConfig1.PopulateFromARM(owner, *typedInput.Properties.DnsConfig)
			if err != nil {
				return err
			}
			dnsConfig := dnsConfig1
			trafficmanagerprofile.DnsConfig = &dnsConfig
		}
	}

	// Set property ‘Endpoints’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Endpoints {
			var item1 Endpoint
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			trafficmanagerprofile.Endpoints = append(trafficmanagerprofile.Endpoints, item1)
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		trafficmanagerprofile.Location = &location
	}

	// Set property ‘MaxReturn’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxReturn != nil {
			maxReturn := *typedInput.Properties.MaxReturn
			trafficmanagerprofile.MaxReturn = &maxReturn
		}
	}

	// Set property ‘MonitorConfig’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MonitorConfig != nil {
			var monitorConfig1 MonitorConfig
			err := monitorConfig1.PopulateFromARM(owner, *typedInput.Properties.MonitorConfig)
			if err != nil {
				return err
			}
			monitorConfig := monitorConfig1
			trafficmanagerprofile.MonitorConfig = &monitorConfig
		}
	}

	// Set property ‘ProfileStatus’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProfileStatus != nil {
			profileStatus := *typedInput.Properties.ProfileStatus
			trafficmanagerprofile.ProfileStatus = &profileStatus
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		trafficmanagerprofile.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			trafficmanagerprofile.Tags[key] = value
		}
	}

	// Set property ‘TrafficRoutingMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficRoutingMethod != nil {
			trafficRoutingMethod := *typedInput.Properties.TrafficRoutingMethod
			trafficmanagerprofile.TrafficRoutingMethod = &trafficRoutingMethod
		}
	}

	// Set property ‘TrafficViewEnrollmentStatus’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficViewEnrollmentStatus != nil {
			trafficViewEnrollmentStatus := *typedInput.Properties.TrafficViewEnrollmentStatus
			trafficmanagerprofile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		trafficmanagerprofile.Type = &typeVar
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Trafficmanagerprofile_Spec{}

// ConvertSpecFrom populates our Trafficmanagerprofile_Spec from the provided source
func (trafficmanagerprofile *Trafficmanagerprofile_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20180801s.Trafficmanagerprofile_Spec)
	if ok {
		// Populate our instance from source
		return trafficmanagerprofile.AssignProperties_From_Trafficmanagerprofile_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20180801s.Trafficmanagerprofile_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = trafficmanagerprofile.AssignProperties_From_Trafficmanagerprofile_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Trafficmanagerprofile_Spec
func (trafficmanagerprofile *Trafficmanagerprofile_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20180801s.Trafficmanagerprofile_Spec)
	if ok {
		// Populate destination from our instance
		return trafficmanagerprofile.AssignProperties_To_Trafficmanagerprofile_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20180801s.Trafficmanagerprofile_Spec{}
	err := trafficmanagerprofile.AssignProperties_To_Trafficmanagerprofile_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Trafficmanagerprofile_Spec populates our Trafficmanagerprofile_Spec from the provided source Trafficmanagerprofile_Spec
func (trafficmanagerprofile *Trafficmanagerprofile_Spec) AssignProperties_From_Trafficmanagerprofile_Spec(source *v20180801s.Trafficmanagerprofile_Spec) error {

	// AllowedEndpointRecordTypes
	if source.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]AllowedEndpointRecordType, len(source.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range source.AllowedEndpointRecordTypes {
			// Shadow the loop variable to avoid aliasing
			allowedEndpointRecordTypeItem := allowedEndpointRecordTypeItem
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = AllowedEndpointRecordType(allowedEndpointRecordTypeItem)
		}
		trafficmanagerprofile.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		trafficmanagerprofile.AllowedEndpointRecordTypes = nil
	}

	// AzureName
	trafficmanagerprofile.AzureName = source.AzureName

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfig
		err := dnsConfig.AssignProperties_From_DnsConfig(source.DnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DnsConfig() to populate field DnsConfig")
		}
		trafficmanagerprofile.DnsConfig = &dnsConfig
	} else {
		trafficmanagerprofile.DnsConfig = nil
	}

	// Endpoints
	if source.Endpoints != nil {
		endpointList := make([]Endpoint, len(source.Endpoints))
		for endpointIndex, endpointItem := range source.Endpoints {
			// Shadow the loop variable to avoid aliasing
			endpointItem := endpointItem
			var endpoint Endpoint
			err := endpoint.AssignProperties_From_Endpoint(&endpointItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Endpoint() to populate field Endpoints")
			}
			endpointList[endpointIndex] = endpoint
		}
		trafficmanagerprofile.Endpoints = endpointList
	} else {
		trafficmanagerprofile.Endpoints = nil
	}

	// Location
	trafficmanagerprofile.Location = genruntime.ClonePointerToString(source.Location)

	// MaxReturn
	trafficmanagerprofile.MaxReturn = genruntime.ClonePointerToInt(source.MaxReturn)

	// MonitorConfig
	if source.MonitorConfig != nil {
		var monitorConfig MonitorConfig
		err := monitorConfig.AssignProperties_From_MonitorConfig(source.MonitorConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MonitorConfig() to populate field MonitorConfig")
		}
		trafficmanagerprofile.MonitorConfig = &monitorConfig
	} else {
		trafficmanagerprofile.MonitorConfig = nil
	}

	// ProfileStatus
	if source.ProfileStatus != nil {
		profileStatus := ProfileProperties_ProfileStatus(*source.ProfileStatus)
		trafficmanagerprofile.ProfileStatus = &profileStatus
	} else {
		trafficmanagerprofile.ProfileStatus = nil
	}

	// Tags
	trafficmanagerprofile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrafficRoutingMethod
	if source.TrafficRoutingMethod != nil {
		trafficRoutingMethod := ProfileProperties_TrafficRoutingMethod(*source.TrafficRoutingMethod)
		trafficmanagerprofile.TrafficRoutingMethod = &trafficRoutingMethod
	} else {
		trafficmanagerprofile.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if source.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := ProfileProperties_TrafficViewEnrollmentStatus(*source.TrafficViewEnrollmentStatus)
		trafficmanagerprofile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
	} else {
		trafficmanagerprofile.TrafficViewEnrollmentStatus = nil
	}

	// Type
	trafficmanagerprofile.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Trafficmanagerprofile_Spec populates the provided destination Trafficmanagerprofile_Spec from our Trafficmanagerprofile_Spec
func (trafficmanagerprofile *Trafficmanagerprofile_Spec) AssignProperties_To_Trafficmanagerprofile_Spec(destination *v20180801s.Trafficmanagerprofile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedEndpointRecordTypes
	if trafficmanagerprofile.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]string, len(trafficmanagerprofile.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range trafficmanagerprofile.AllowedEndpointRecordTypes {
			// Shadow the loop variable to avoid aliasing
			allowedEndpointRecordTypeItem := allowedEndpointRecordTypeItem
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = string(allowedEndpointRecordTypeItem)
		}
		destination.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		destination.AllowedEndpointRecordTypes = nil
	}

	// AzureName
	destination.AzureName = trafficmanagerprofile.AzureName

	// DnsConfig
	if trafficmanagerprofile.DnsConfig != nil {
		var dnsConfig v20180801s.DnsConfig
		err := trafficmanagerprofile.DnsConfig.AssignProperties_To_DnsConfig(&dnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DnsConfig() to populate field DnsConfig")
		}
		destination.DnsConfig = &dnsConfig
	} else {
		destination.DnsConfig = nil
	}

	// Endpoints
	if trafficmanagerprofile.Endpoints != nil {
		endpointList := make([]v20180801s.Endpoint, len(trafficmanagerprofile.Endpoints))
		for endpointIndex, endpointItem := range trafficmanagerprofile.Endpoints {
			// Shadow the loop variable to avoid aliasing
			endpointItem := endpointItem
			var endpoint v20180801s.Endpoint
			err := endpointItem.AssignProperties_To_Endpoint(&endpoint)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Endpoint() to populate field Endpoints")
			}
			endpointList[endpointIndex] = endpoint
		}
		destination.Endpoints = endpointList
	} else {
		destination.Endpoints = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(trafficmanagerprofile.Location)

	// MaxReturn
	destination.MaxReturn = genruntime.ClonePointerToInt(trafficmanagerprofile.MaxReturn)

	// MonitorConfig
	if trafficmanagerprofile.MonitorConfig != nil {
		var monitorConfig v20180801s.MonitorConfig
		err := trafficmanagerprofile.MonitorConfig.AssignProperties_To_MonitorConfig(&monitorConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MonitorConfig() to populate field MonitorConfig")
		}
		destination.MonitorConfig = &monitorConfig
	} else {
		destination.MonitorConfig = nil
	}

	// OriginalVersion
	destination.OriginalVersion = trafficmanagerprofile.OriginalVersion()

	// ProfileStatus
	if trafficmanagerprofile.ProfileStatus != nil {
		profileStatus := string(*trafficmanagerprofile.ProfileStatus)
		destination.ProfileStatus = &profileStatus
	} else {
		destination.ProfileStatus = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(trafficmanagerprofile.Tags)

	// TrafficRoutingMethod
	if trafficmanagerprofile.TrafficRoutingMethod != nil {
		trafficRoutingMethod := string(*trafficmanagerprofile.TrafficRoutingMethod)
		destination.TrafficRoutingMethod = &trafficRoutingMethod
	} else {
		destination.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if trafficmanagerprofile.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := string(*trafficmanagerprofile.TrafficViewEnrollmentStatus)
		destination.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
	} else {
		destination.TrafficViewEnrollmentStatus = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(trafficmanagerprofile.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (trafficmanagerprofile *Trafficmanagerprofile_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (trafficmanagerprofile *Trafficmanagerprofile_Spec) SetAzureName(azureName string) {
	trafficmanagerprofile.AzureName = azureName
}

type Trafficmanagerprofile_STATUS struct {
	// AllowedEndpointRecordTypes: The list of allowed endpoint record types.
	AllowedEndpointRecordTypes []AllowedEndpointRecordType_STATUS `json:"allowedEndpointRecordTypes,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// DnsConfig: The DNS settings of the Traffic Manager profile.
	DnsConfig *DnsConfig_STATUS `json:"dnsConfig,omitempty"`

	// Endpoints: The list of endpoints in the Traffic Manager profile.
	Endpoints []Endpoint_STATUS `json:"endpoints,omitempty"`

	// Id: Fully qualified resource Id for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
	Id *string `json:"id,omitempty"`

	// Location: The Azure Region where the resource lives
	Location *string `json:"location,omitempty"`

	// MaxReturn: Maximum number of endpoints to be returned for MultiValue routing type.
	MaxReturn *int `json:"maxReturn,omitempty"`

	// MonitorConfig: The endpoint monitoring settings of the Traffic Manager profile.
	MonitorConfig *MonitorConfig_STATUS `json:"monitorConfig,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// ProfileStatus: The status of the Traffic Manager profile.
	ProfileStatus *ProfileProperties_ProfileStatus_STATUS `json:"profileStatus,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TrafficRoutingMethod: The traffic routing method of the Traffic Manager profile.
	TrafficRoutingMethod *ProfileProperties_TrafficRoutingMethod_STATUS `json:"trafficRoutingMethod,omitempty"`

	// TrafficViewEnrollmentStatus: Indicates whether Traffic View is 'Enabled' or 'Disabled' for the Traffic Manager profile.
	// Null, indicates 'Disabled'. Enabling this feature will increase the cost of the Traffic Manage profile.
	TrafficViewEnrollmentStatus *ProfileProperties_TrafficViewEnrollmentStatus_STATUS `json:"trafficViewEnrollmentStatus,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Trafficmanagerprofile_STATUS{}

// ConvertStatusFrom populates our Trafficmanagerprofile_STATUS from the provided source
func (trafficmanagerprofile *Trafficmanagerprofile_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20180801s.Trafficmanagerprofile_STATUS)
	if ok {
		// Populate our instance from source
		return trafficmanagerprofile.AssignProperties_From_Trafficmanagerprofile_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20180801s.Trafficmanagerprofile_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = trafficmanagerprofile.AssignProperties_From_Trafficmanagerprofile_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Trafficmanagerprofile_STATUS
func (trafficmanagerprofile *Trafficmanagerprofile_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20180801s.Trafficmanagerprofile_STATUS)
	if ok {
		// Populate destination from our instance
		return trafficmanagerprofile.AssignProperties_To_Trafficmanagerprofile_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20180801s.Trafficmanagerprofile_STATUS{}
	err := trafficmanagerprofile.AssignProperties_To_Trafficmanagerprofile_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Trafficmanagerprofile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trafficmanagerprofile *Trafficmanagerprofile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Trafficmanagerprofile_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trafficmanagerprofile *Trafficmanagerprofile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Trafficmanagerprofile_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Trafficmanagerprofile_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘AllowedEndpointRecordTypes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AllowedEndpointRecordTypes {
			trafficmanagerprofile.AllowedEndpointRecordTypes = append(trafficmanagerprofile.AllowedEndpointRecordTypes, item)
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘DnsConfig’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsConfig != nil {
			var dnsConfig1 DnsConfig_STATUS
			err := dnsConfig1.PopulateFromARM(owner, *typedInput.Properties.DnsConfig)
			if err != nil {
				return err
			}
			dnsConfig := dnsConfig1
			trafficmanagerprofile.DnsConfig = &dnsConfig
		}
	}

	// Set property ‘Endpoints’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Endpoints {
			var item1 Endpoint_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			trafficmanagerprofile.Endpoints = append(trafficmanagerprofile.Endpoints, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		trafficmanagerprofile.Id = &id
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		trafficmanagerprofile.Location = &location
	}

	// Set property ‘MaxReturn’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxReturn != nil {
			maxReturn := *typedInput.Properties.MaxReturn
			trafficmanagerprofile.MaxReturn = &maxReturn
		}
	}

	// Set property ‘MonitorConfig’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MonitorConfig != nil {
			var monitorConfig1 MonitorConfig_STATUS
			err := monitorConfig1.PopulateFromARM(owner, *typedInput.Properties.MonitorConfig)
			if err != nil {
				return err
			}
			monitorConfig := monitorConfig1
			trafficmanagerprofile.MonitorConfig = &monitorConfig
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		trafficmanagerprofile.Name = &name
	}

	// Set property ‘ProfileStatus’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProfileStatus != nil {
			profileStatus := *typedInput.Properties.ProfileStatus
			trafficmanagerprofile.ProfileStatus = &profileStatus
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		trafficmanagerprofile.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			trafficmanagerprofile.Tags[key] = value
		}
	}

	// Set property ‘TrafficRoutingMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficRoutingMethod != nil {
			trafficRoutingMethod := *typedInput.Properties.TrafficRoutingMethod
			trafficmanagerprofile.TrafficRoutingMethod = &trafficRoutingMethod
		}
	}

	// Set property ‘TrafficViewEnrollmentStatus’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficViewEnrollmentStatus != nil {
			trafficViewEnrollmentStatus := *typedInput.Properties.TrafficViewEnrollmentStatus
			trafficmanagerprofile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		trafficmanagerprofile.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Trafficmanagerprofile_STATUS populates our Trafficmanagerprofile_STATUS from the provided source Trafficmanagerprofile_STATUS
func (trafficmanagerprofile *Trafficmanagerprofile_STATUS) AssignProperties_From_Trafficmanagerprofile_STATUS(source *v20180801s.Trafficmanagerprofile_STATUS) error {

	// AllowedEndpointRecordTypes
	if source.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]AllowedEndpointRecordType_STATUS, len(source.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range source.AllowedEndpointRecordTypes {
			// Shadow the loop variable to avoid aliasing
			allowedEndpointRecordTypeItem := allowedEndpointRecordTypeItem
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = AllowedEndpointRecordType_STATUS(allowedEndpointRecordTypeItem)
		}
		trafficmanagerprofile.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		trafficmanagerprofile.AllowedEndpointRecordTypes = nil
	}

	// Conditions
	trafficmanagerprofile.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfig_STATUS
		err := dnsConfig.AssignProperties_From_DnsConfig_STATUS(source.DnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DnsConfig_STATUS() to populate field DnsConfig")
		}
		trafficmanagerprofile.DnsConfig = &dnsConfig
	} else {
		trafficmanagerprofile.DnsConfig = nil
	}

	// Endpoints
	if source.Endpoints != nil {
		endpointList := make([]Endpoint_STATUS, len(source.Endpoints))
		for endpointIndex, endpointItem := range source.Endpoints {
			// Shadow the loop variable to avoid aliasing
			endpointItem := endpointItem
			var endpoint Endpoint_STATUS
			err := endpoint.AssignProperties_From_Endpoint_STATUS(&endpointItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Endpoint_STATUS() to populate field Endpoints")
			}
			endpointList[endpointIndex] = endpoint
		}
		trafficmanagerprofile.Endpoints = endpointList
	} else {
		trafficmanagerprofile.Endpoints = nil
	}

	// Id
	trafficmanagerprofile.Id = genruntime.ClonePointerToString(source.Id)

	// Location
	trafficmanagerprofile.Location = genruntime.ClonePointerToString(source.Location)

	// MaxReturn
	trafficmanagerprofile.MaxReturn = genruntime.ClonePointerToInt(source.MaxReturn)

	// MonitorConfig
	if source.MonitorConfig != nil {
		var monitorConfig MonitorConfig_STATUS
		err := monitorConfig.AssignProperties_From_MonitorConfig_STATUS(source.MonitorConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MonitorConfig_STATUS() to populate field MonitorConfig")
		}
		trafficmanagerprofile.MonitorConfig = &monitorConfig
	} else {
		trafficmanagerprofile.MonitorConfig = nil
	}

	// Name
	trafficmanagerprofile.Name = genruntime.ClonePointerToString(source.Name)

	// ProfileStatus
	if source.ProfileStatus != nil {
		profileStatus := ProfileProperties_ProfileStatus_STATUS(*source.ProfileStatus)
		trafficmanagerprofile.ProfileStatus = &profileStatus
	} else {
		trafficmanagerprofile.ProfileStatus = nil
	}

	// Tags
	trafficmanagerprofile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrafficRoutingMethod
	if source.TrafficRoutingMethod != nil {
		trafficRoutingMethod := ProfileProperties_TrafficRoutingMethod_STATUS(*source.TrafficRoutingMethod)
		trafficmanagerprofile.TrafficRoutingMethod = &trafficRoutingMethod
	} else {
		trafficmanagerprofile.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if source.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := ProfileProperties_TrafficViewEnrollmentStatus_STATUS(*source.TrafficViewEnrollmentStatus)
		trafficmanagerprofile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
	} else {
		trafficmanagerprofile.TrafficViewEnrollmentStatus = nil
	}

	// Type
	trafficmanagerprofile.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Trafficmanagerprofile_STATUS populates the provided destination Trafficmanagerprofile_STATUS from our Trafficmanagerprofile_STATUS
func (trafficmanagerprofile *Trafficmanagerprofile_STATUS) AssignProperties_To_Trafficmanagerprofile_STATUS(destination *v20180801s.Trafficmanagerprofile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedEndpointRecordTypes
	if trafficmanagerprofile.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]string, len(trafficmanagerprofile.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range trafficmanagerprofile.AllowedEndpointRecordTypes {
			// Shadow the loop variable to avoid aliasing
			allowedEndpointRecordTypeItem := allowedEndpointRecordTypeItem
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = string(allowedEndpointRecordTypeItem)
		}
		destination.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		destination.AllowedEndpointRecordTypes = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(trafficmanagerprofile.Conditions)

	// DnsConfig
	if trafficmanagerprofile.DnsConfig != nil {
		var dnsConfig v20180801s.DnsConfig_STATUS
		err := trafficmanagerprofile.DnsConfig.AssignProperties_To_DnsConfig_STATUS(&dnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DnsConfig_STATUS() to populate field DnsConfig")
		}
		destination.DnsConfig = &dnsConfig
	} else {
		destination.DnsConfig = nil
	}

	// Endpoints
	if trafficmanagerprofile.Endpoints != nil {
		endpointList := make([]v20180801s.Endpoint_STATUS, len(trafficmanagerprofile.Endpoints))
		for endpointIndex, endpointItem := range trafficmanagerprofile.Endpoints {
			// Shadow the loop variable to avoid aliasing
			endpointItem := endpointItem
			var endpoint v20180801s.Endpoint_STATUS
			err := endpointItem.AssignProperties_To_Endpoint_STATUS(&endpoint)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Endpoint_STATUS() to populate field Endpoints")
			}
			endpointList[endpointIndex] = endpoint
		}
		destination.Endpoints = endpointList
	} else {
		destination.Endpoints = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(trafficmanagerprofile.Id)

	// Location
	destination.Location = genruntime.ClonePointerToString(trafficmanagerprofile.Location)

	// MaxReturn
	destination.MaxReturn = genruntime.ClonePointerToInt(trafficmanagerprofile.MaxReturn)

	// MonitorConfig
	if trafficmanagerprofile.MonitorConfig != nil {
		var monitorConfig v20180801s.MonitorConfig_STATUS
		err := trafficmanagerprofile.MonitorConfig.AssignProperties_To_MonitorConfig_STATUS(&monitorConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MonitorConfig_STATUS() to populate field MonitorConfig")
		}
		destination.MonitorConfig = &monitorConfig
	} else {
		destination.MonitorConfig = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(trafficmanagerprofile.Name)

	// ProfileStatus
	if trafficmanagerprofile.ProfileStatus != nil {
		profileStatus := string(*trafficmanagerprofile.ProfileStatus)
		destination.ProfileStatus = &profileStatus
	} else {
		destination.ProfileStatus = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(trafficmanagerprofile.Tags)

	// TrafficRoutingMethod
	if trafficmanagerprofile.TrafficRoutingMethod != nil {
		trafficRoutingMethod := string(*trafficmanagerprofile.TrafficRoutingMethod)
		destination.TrafficRoutingMethod = &trafficRoutingMethod
	} else {
		destination.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if trafficmanagerprofile.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := string(*trafficmanagerprofile.TrafficViewEnrollmentStatus)
		destination.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
	} else {
		destination.TrafficViewEnrollmentStatus = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(trafficmanagerprofile.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The allowed type DNS record types for this profile.
// +kubebuilder:validation:Enum={"Any","DomainName","IPv4Address","IPv6Address"}
type AllowedEndpointRecordType string

const (
	AllowedEndpointRecordType_Any         = AllowedEndpointRecordType("Any")
	AllowedEndpointRecordType_DomainName  = AllowedEndpointRecordType("DomainName")
	AllowedEndpointRecordType_IPv4Address = AllowedEndpointRecordType("IPv4Address")
	AllowedEndpointRecordType_IPv6Address = AllowedEndpointRecordType("IPv6Address")
)

// The allowed type DNS record types for this profile.
type AllowedEndpointRecordType_STATUS string

const (
	AllowedEndpointRecordType_STATUS_Any         = AllowedEndpointRecordType_STATUS("Any")
	AllowedEndpointRecordType_STATUS_DomainName  = AllowedEndpointRecordType_STATUS("DomainName")
	AllowedEndpointRecordType_STATUS_IPv4Address = AllowedEndpointRecordType_STATUS("IPv4Address")
	AllowedEndpointRecordType_STATUS_IPv6Address = AllowedEndpointRecordType_STATUS("IPv6Address")
)

// Class containing DNS settings in a Traffic Manager profile.
type DnsConfig struct {
	// RelativeName: The relative DNS name provided by this Traffic Manager profile. This value is combined with the DNS domain
	// name used by Azure Traffic Manager to form the fully-qualified domain name (FQDN) of the profile.
	RelativeName *string `json:"relativeName,omitempty"`

	// Ttl: The DNS Time-To-Live (TTL), in seconds. This informs the local DNS resolvers and DNS clients how long to cache DNS
	// responses provided by this Traffic Manager profile.
	Ttl *int `json:"ttl,omitempty"`
}

var _ genruntime.ARMTransformer = &DnsConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *DnsConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &DnsConfig_ARM{}

	// Set property ‘RelativeName’:
	if config.RelativeName != nil {
		relativeName := *config.RelativeName
		result.RelativeName = &relativeName
	}

	// Set property ‘Ttl’:
	if config.Ttl != nil {
		ttl := *config.Ttl
		result.Ttl = &ttl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *DnsConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DnsConfig_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *DnsConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DnsConfig_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DnsConfig_ARM, got %T", armInput)
	}

	// Set property ‘RelativeName’:
	if typedInput.RelativeName != nil {
		relativeName := *typedInput.RelativeName
		config.RelativeName = &relativeName
	}

	// Set property ‘Ttl’:
	if typedInput.Ttl != nil {
		ttl := *typedInput.Ttl
		config.Ttl = &ttl
	}

	// No error
	return nil
}

// AssignProperties_From_DnsConfig populates our DnsConfig from the provided source DnsConfig
func (config *DnsConfig) AssignProperties_From_DnsConfig(source *v20180801s.DnsConfig) error {

	// RelativeName
	config.RelativeName = genruntime.ClonePointerToString(source.RelativeName)

	// Ttl
	config.Ttl = genruntime.ClonePointerToInt(source.Ttl)

	// No error
	return nil
}

// AssignProperties_To_DnsConfig populates the provided destination DnsConfig from our DnsConfig
func (config *DnsConfig) AssignProperties_To_DnsConfig(destination *v20180801s.DnsConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RelativeName
	destination.RelativeName = genruntime.ClonePointerToString(config.RelativeName)

	// Ttl
	destination.Ttl = genruntime.ClonePointerToInt(config.Ttl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class containing DNS settings in a Traffic Manager profile.
type DnsConfig_STATUS struct {
	// Fqdn: The fully-qualified domain name (FQDN) of the Traffic Manager profile. This is formed from the concatenation of
	// the RelativeName with the DNS domain used by Azure Traffic Manager.
	Fqdn *string `json:"fqdn,omitempty"`

	// RelativeName: The relative DNS name provided by this Traffic Manager profile. This value is combined with the DNS domain
	// name used by Azure Traffic Manager to form the fully-qualified domain name (FQDN) of the profile.
	RelativeName *string `json:"relativeName,omitempty"`

	// Ttl: The DNS Time-To-Live (TTL), in seconds. This informs the local DNS resolvers and DNS clients how long to cache DNS
	// responses provided by this Traffic Manager profile.
	Ttl *int `json:"ttl,omitempty"`
}

var _ genruntime.FromARMConverter = &DnsConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *DnsConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DnsConfig_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *DnsConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DnsConfig_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DnsConfig_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Fqdn’:
	if typedInput.Fqdn != nil {
		fqdn := *typedInput.Fqdn
		config.Fqdn = &fqdn
	}

	// Set property ‘RelativeName’:
	if typedInput.RelativeName != nil {
		relativeName := *typedInput.RelativeName
		config.RelativeName = &relativeName
	}

	// Set property ‘Ttl’:
	if typedInput.Ttl != nil {
		ttl := *typedInput.Ttl
		config.Ttl = &ttl
	}

	// No error
	return nil
}

// AssignProperties_From_DnsConfig_STATUS populates our DnsConfig_STATUS from the provided source DnsConfig_STATUS
func (config *DnsConfig_STATUS) AssignProperties_From_DnsConfig_STATUS(source *v20180801s.DnsConfig_STATUS) error {

	// Fqdn
	config.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// RelativeName
	config.RelativeName = genruntime.ClonePointerToString(source.RelativeName)

	// Ttl
	config.Ttl = genruntime.ClonePointerToInt(source.Ttl)

	// No error
	return nil
}

// AssignProperties_To_DnsConfig_STATUS populates the provided destination DnsConfig_STATUS from our DnsConfig_STATUS
func (config *DnsConfig_STATUS) AssignProperties_To_DnsConfig_STATUS(destination *v20180801s.DnsConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(config.Fqdn)

	// RelativeName
	destination.RelativeName = genruntime.ClonePointerToString(config.RelativeName)

	// Ttl
	destination.Ttl = genruntime.ClonePointerToInt(config.Ttl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class representing a Traffic Manager endpoint.
type Endpoint struct {
	// Reference: Fully qualified resource Id for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &Endpoint{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (endpoint *Endpoint) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if endpoint == nil {
		return nil, nil
	}
	result := &Endpoint_ARM{}

	// Set property ‘Id’:
	if endpoint.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*endpoint.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *Endpoint) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Endpoint_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *Endpoint) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(Endpoint_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Endpoint_ARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignProperties_From_Endpoint populates our Endpoint from the provided source Endpoint
func (endpoint *Endpoint) AssignProperties_From_Endpoint(source *v20180801s.Endpoint) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		endpoint.Reference = &reference
	} else {
		endpoint.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Endpoint populates the provided destination Endpoint from our Endpoint
func (endpoint *Endpoint) AssignProperties_To_Endpoint(destination *v20180801s.Endpoint) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if endpoint.Reference != nil {
		reference := endpoint.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class representing a Traffic Manager endpoint.
type Endpoint_STATUS struct {
	// Id: Fully qualified resource Id for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &Endpoint_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *Endpoint_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Endpoint_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *Endpoint_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Endpoint_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Endpoint_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		endpoint.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_Endpoint_STATUS populates our Endpoint_STATUS from the provided source Endpoint_STATUS
func (endpoint *Endpoint_STATUS) AssignProperties_From_Endpoint_STATUS(source *v20180801s.Endpoint_STATUS) error {

	// Id
	endpoint.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_Endpoint_STATUS populates the provided destination Endpoint_STATUS from our Endpoint_STATUS
func (endpoint *Endpoint_STATUS) AssignProperties_To_Endpoint_STATUS(destination *v20180801s.Endpoint_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(endpoint.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class containing endpoint monitoring settings in a Traffic Manager profile.
type MonitorConfig struct {
	// CustomHeaders: List of custom headers.
	CustomHeaders []MonitorConfig_CustomHeaders `json:"customHeaders,omitempty"`

	// ExpectedStatusCodeRanges: List of expected status code ranges.
	ExpectedStatusCodeRanges []MonitorConfig_ExpectedStatusCodeRanges `json:"expectedStatusCodeRanges,omitempty"`

	// IntervalInSeconds: The monitor interval for endpoints in this profile. This is the interval at which Traffic Manager
	// will check the health of each endpoint in this profile.
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	// Path: The path relative to the endpoint domain name used to probe for endpoint health.
	Path *string `json:"path,omitempty"`

	// Port: The TCP port used to probe for endpoint health.
	Port *int `json:"port,omitempty"`

	// ProfileMonitorStatus: The profile-level monitoring status of the Traffic Manager profile.
	ProfileMonitorStatus *MonitorConfig_ProfileMonitorStatus `json:"profileMonitorStatus,omitempty"`

	// Protocol: The protocol (HTTP, HTTPS or TCP) used to probe for endpoint health.
	Protocol *MonitorConfig_Protocol `json:"protocol,omitempty"`

	// TimeoutInSeconds: The monitor timeout for endpoints in this profile. This is the time that Traffic Manager allows
	// endpoints in this profile to response to the health check.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// ToleratedNumberOfFailures: The number of consecutive failed health check that Traffic Manager tolerates before declaring
	// an endpoint in this profile Degraded after the next failed health check.
	ToleratedNumberOfFailures *int `json:"toleratedNumberOfFailures,omitempty"`
}

var _ genruntime.ARMTransformer = &MonitorConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *MonitorConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &MonitorConfig_ARM{}

	// Set property ‘CustomHeaders’:
	for _, item := range config.CustomHeaders {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.CustomHeaders = append(result.CustomHeaders, *item_ARM.(*MonitorConfig_CustomHeaders_ARM))
	}

	// Set property ‘ExpectedStatusCodeRanges’:
	for _, item := range config.ExpectedStatusCodeRanges {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ExpectedStatusCodeRanges = append(result.ExpectedStatusCodeRanges, *item_ARM.(*MonitorConfig_ExpectedStatusCodeRanges_ARM))
	}

	// Set property ‘IntervalInSeconds’:
	if config.IntervalInSeconds != nil {
		intervalInSeconds := *config.IntervalInSeconds
		result.IntervalInSeconds = &intervalInSeconds
	}

	// Set property ‘Path’:
	if config.Path != nil {
		path := *config.Path
		result.Path = &path
	}

	// Set property ‘Port’:
	if config.Port != nil {
		port := *config.Port
		result.Port = &port
	}

	// Set property ‘ProfileMonitorStatus’:
	if config.ProfileMonitorStatus != nil {
		profileMonitorStatus := *config.ProfileMonitorStatus
		result.ProfileMonitorStatus = &profileMonitorStatus
	}

	// Set property ‘Protocol’:
	if config.Protocol != nil {
		protocol := *config.Protocol
		result.Protocol = &protocol
	}

	// Set property ‘TimeoutInSeconds’:
	if config.TimeoutInSeconds != nil {
		timeoutInSeconds := *config.TimeoutInSeconds
		result.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property ‘ToleratedNumberOfFailures’:
	if config.ToleratedNumberOfFailures != nil {
		toleratedNumberOfFailures := *config.ToleratedNumberOfFailures
		result.ToleratedNumberOfFailures = &toleratedNumberOfFailures
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *MonitorConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MonitorConfig_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *MonitorConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MonitorConfig_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MonitorConfig_ARM, got %T", armInput)
	}

	// Set property ‘CustomHeaders’:
	for _, item := range typedInput.CustomHeaders {
		var item1 MonitorConfig_CustomHeaders
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.CustomHeaders = append(config.CustomHeaders, item1)
	}

	// Set property ‘ExpectedStatusCodeRanges’:
	for _, item := range typedInput.ExpectedStatusCodeRanges {
		var item1 MonitorConfig_ExpectedStatusCodeRanges
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ExpectedStatusCodeRanges = append(config.ExpectedStatusCodeRanges, item1)
	}

	// Set property ‘IntervalInSeconds’:
	if typedInput.IntervalInSeconds != nil {
		intervalInSeconds := *typedInput.IntervalInSeconds
		config.IntervalInSeconds = &intervalInSeconds
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		config.Path = &path
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port := *typedInput.Port
		config.Port = &port
	}

	// Set property ‘ProfileMonitorStatus’:
	if typedInput.ProfileMonitorStatus != nil {
		profileMonitorStatus := *typedInput.ProfileMonitorStatus
		config.ProfileMonitorStatus = &profileMonitorStatus
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		config.Protocol = &protocol
	}

	// Set property ‘TimeoutInSeconds’:
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		config.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property ‘ToleratedNumberOfFailures’:
	if typedInput.ToleratedNumberOfFailures != nil {
		toleratedNumberOfFailures := *typedInput.ToleratedNumberOfFailures
		config.ToleratedNumberOfFailures = &toleratedNumberOfFailures
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig populates our MonitorConfig from the provided source MonitorConfig
func (config *MonitorConfig) AssignProperties_From_MonitorConfig(source *v20180801s.MonitorConfig) error {

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]MonitorConfig_CustomHeaders, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader MonitorConfig_CustomHeaders
			err := customHeader.AssignProperties_From_MonitorConfig_CustomHeaders(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MonitorConfig_CustomHeaders() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		config.CustomHeaders = customHeaderList
	} else {
		config.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if source.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]MonitorConfig_ExpectedStatusCodeRanges, len(source.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range source.ExpectedStatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			expectedStatusCodeRangeItem := expectedStatusCodeRangeItem
			var expectedStatusCodeRange MonitorConfig_ExpectedStatusCodeRanges
			err := expectedStatusCodeRange.AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges(&expectedStatusCodeRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		config.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		config.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	config.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// Path
	config.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	config.Port = genruntime.ClonePointerToInt(source.Port)

	// ProfileMonitorStatus
	if source.ProfileMonitorStatus != nil {
		profileMonitorStatus := MonitorConfig_ProfileMonitorStatus(*source.ProfileMonitorStatus)
		config.ProfileMonitorStatus = &profileMonitorStatus
	} else {
		config.ProfileMonitorStatus = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := MonitorConfig_Protocol(*source.Protocol)
		config.Protocol = &protocol
	} else {
		config.Protocol = nil
	}

	// TimeoutInSeconds
	config.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	config.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(source.ToleratedNumberOfFailures)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig populates the provided destination MonitorConfig from our MonitorConfig
func (config *MonitorConfig) AssignProperties_To_MonitorConfig(destination *v20180801s.MonitorConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomHeaders
	if config.CustomHeaders != nil {
		customHeaderList := make([]v20180801s.MonitorConfig_CustomHeaders, len(config.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range config.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader v20180801s.MonitorConfig_CustomHeaders
			err := customHeaderItem.AssignProperties_To_MonitorConfig_CustomHeaders(&customHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MonitorConfig_CustomHeaders() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if config.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]v20180801s.MonitorConfig_ExpectedStatusCodeRanges, len(config.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range config.ExpectedStatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			expectedStatusCodeRangeItem := expectedStatusCodeRangeItem
			var expectedStatusCodeRange v20180801s.MonitorConfig_ExpectedStatusCodeRanges
			err := expectedStatusCodeRangeItem.AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges(&expectedStatusCodeRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		destination.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		destination.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(config.IntervalInSeconds)

	// Path
	destination.Path = genruntime.ClonePointerToString(config.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(config.Port)

	// ProfileMonitorStatus
	if config.ProfileMonitorStatus != nil {
		profileMonitorStatus := string(*config.ProfileMonitorStatus)
		destination.ProfileMonitorStatus = &profileMonitorStatus
	} else {
		destination.ProfileMonitorStatus = nil
	}

	// Protocol
	if config.Protocol != nil {
		protocol := string(*config.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(config.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	destination.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(config.ToleratedNumberOfFailures)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class containing endpoint monitoring settings in a Traffic Manager profile.
type MonitorConfig_STATUS struct {
	// CustomHeaders: List of custom headers.
	CustomHeaders []MonitorConfig_CustomHeaders_STATUS `json:"customHeaders,omitempty"`

	// ExpectedStatusCodeRanges: List of expected status code ranges.
	ExpectedStatusCodeRanges []MonitorConfig_ExpectedStatusCodeRanges_STATUS `json:"expectedStatusCodeRanges,omitempty"`

	// IntervalInSeconds: The monitor interval for endpoints in this profile. This is the interval at which Traffic Manager
	// will check the health of each endpoint in this profile.
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	// Path: The path relative to the endpoint domain name used to probe for endpoint health.
	Path *string `json:"path,omitempty"`

	// Port: The TCP port used to probe for endpoint health.
	Port *int `json:"port,omitempty"`

	// ProfileMonitorStatus: The profile-level monitoring status of the Traffic Manager profile.
	ProfileMonitorStatus *MonitorConfig_ProfileMonitorStatus_STATUS `json:"profileMonitorStatus,omitempty"`

	// Protocol: The protocol (HTTP, HTTPS or TCP) used to probe for endpoint health.
	Protocol *MonitorConfig_Protocol_STATUS `json:"protocol,omitempty"`

	// TimeoutInSeconds: The monitor timeout for endpoints in this profile. This is the time that Traffic Manager allows
	// endpoints in this profile to response to the health check.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// ToleratedNumberOfFailures: The number of consecutive failed health check that Traffic Manager tolerates before declaring
	// an endpoint in this profile Degraded after the next failed health check.
	ToleratedNumberOfFailures *int `json:"toleratedNumberOfFailures,omitempty"`
}

var _ genruntime.FromARMConverter = &MonitorConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *MonitorConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MonitorConfig_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *MonitorConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MonitorConfig_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MonitorConfig_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘CustomHeaders’:
	for _, item := range typedInput.CustomHeaders {
		var item1 MonitorConfig_CustomHeaders_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.CustomHeaders = append(config.CustomHeaders, item1)
	}

	// Set property ‘ExpectedStatusCodeRanges’:
	for _, item := range typedInput.ExpectedStatusCodeRanges {
		var item1 MonitorConfig_ExpectedStatusCodeRanges_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ExpectedStatusCodeRanges = append(config.ExpectedStatusCodeRanges, item1)
	}

	// Set property ‘IntervalInSeconds’:
	if typedInput.IntervalInSeconds != nil {
		intervalInSeconds := *typedInput.IntervalInSeconds
		config.IntervalInSeconds = &intervalInSeconds
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		config.Path = &path
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port := *typedInput.Port
		config.Port = &port
	}

	// Set property ‘ProfileMonitorStatus’:
	if typedInput.ProfileMonitorStatus != nil {
		profileMonitorStatus := *typedInput.ProfileMonitorStatus
		config.ProfileMonitorStatus = &profileMonitorStatus
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		config.Protocol = &protocol
	}

	// Set property ‘TimeoutInSeconds’:
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		config.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property ‘ToleratedNumberOfFailures’:
	if typedInput.ToleratedNumberOfFailures != nil {
		toleratedNumberOfFailures := *typedInput.ToleratedNumberOfFailures
		config.ToleratedNumberOfFailures = &toleratedNumberOfFailures
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig_STATUS populates our MonitorConfig_STATUS from the provided source MonitorConfig_STATUS
func (config *MonitorConfig_STATUS) AssignProperties_From_MonitorConfig_STATUS(source *v20180801s.MonitorConfig_STATUS) error {

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]MonitorConfig_CustomHeaders_STATUS, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader MonitorConfig_CustomHeaders_STATUS
			err := customHeader.AssignProperties_From_MonitorConfig_CustomHeaders_STATUS(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MonitorConfig_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		config.CustomHeaders = customHeaderList
	} else {
		config.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if source.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]MonitorConfig_ExpectedStatusCodeRanges_STATUS, len(source.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range source.ExpectedStatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			expectedStatusCodeRangeItem := expectedStatusCodeRangeItem
			var expectedStatusCodeRange MonitorConfig_ExpectedStatusCodeRanges_STATUS
			err := expectedStatusCodeRange.AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges_STATUS(&expectedStatusCodeRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges_STATUS() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		config.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		config.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	config.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// Path
	config.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	config.Port = genruntime.ClonePointerToInt(source.Port)

	// ProfileMonitorStatus
	if source.ProfileMonitorStatus != nil {
		profileMonitorStatus := MonitorConfig_ProfileMonitorStatus_STATUS(*source.ProfileMonitorStatus)
		config.ProfileMonitorStatus = &profileMonitorStatus
	} else {
		config.ProfileMonitorStatus = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := MonitorConfig_Protocol_STATUS(*source.Protocol)
		config.Protocol = &protocol
	} else {
		config.Protocol = nil
	}

	// TimeoutInSeconds
	config.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	config.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(source.ToleratedNumberOfFailures)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig_STATUS populates the provided destination MonitorConfig_STATUS from our MonitorConfig_STATUS
func (config *MonitorConfig_STATUS) AssignProperties_To_MonitorConfig_STATUS(destination *v20180801s.MonitorConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomHeaders
	if config.CustomHeaders != nil {
		customHeaderList := make([]v20180801s.MonitorConfig_CustomHeaders_STATUS, len(config.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range config.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader v20180801s.MonitorConfig_CustomHeaders_STATUS
			err := customHeaderItem.AssignProperties_To_MonitorConfig_CustomHeaders_STATUS(&customHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MonitorConfig_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if config.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]v20180801s.MonitorConfig_ExpectedStatusCodeRanges_STATUS, len(config.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range config.ExpectedStatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			expectedStatusCodeRangeItem := expectedStatusCodeRangeItem
			var expectedStatusCodeRange v20180801s.MonitorConfig_ExpectedStatusCodeRanges_STATUS
			err := expectedStatusCodeRangeItem.AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges_STATUS(&expectedStatusCodeRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges_STATUS() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		destination.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		destination.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(config.IntervalInSeconds)

	// Path
	destination.Path = genruntime.ClonePointerToString(config.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(config.Port)

	// ProfileMonitorStatus
	if config.ProfileMonitorStatus != nil {
		profileMonitorStatus := string(*config.ProfileMonitorStatus)
		destination.ProfileMonitorStatus = &profileMonitorStatus
	} else {
		destination.ProfileMonitorStatus = nil
	}

	// Protocol
	if config.Protocol != nil {
		protocol := string(*config.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(config.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	destination.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(config.ToleratedNumberOfFailures)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ProfileProperties_ProfileStatus string

const (
	ProfileProperties_ProfileStatus_Disabled = ProfileProperties_ProfileStatus("Disabled")
	ProfileProperties_ProfileStatus_Enabled  = ProfileProperties_ProfileStatus("Enabled")
)

type ProfileProperties_ProfileStatus_STATUS string

const (
	ProfileProperties_ProfileStatus_STATUS_Disabled = ProfileProperties_ProfileStatus_STATUS("Disabled")
	ProfileProperties_ProfileStatus_STATUS_Enabled  = ProfileProperties_ProfileStatus_STATUS("Enabled")
)

// +kubebuilder:validation:Enum={"Geographic","MultiValue","Performance","Priority","Subnet","Weighted"}
type ProfileProperties_TrafficRoutingMethod string

const (
	ProfileProperties_TrafficRoutingMethod_Geographic  = ProfileProperties_TrafficRoutingMethod("Geographic")
	ProfileProperties_TrafficRoutingMethod_MultiValue  = ProfileProperties_TrafficRoutingMethod("MultiValue")
	ProfileProperties_TrafficRoutingMethod_Performance = ProfileProperties_TrafficRoutingMethod("Performance")
	ProfileProperties_TrafficRoutingMethod_Priority    = ProfileProperties_TrafficRoutingMethod("Priority")
	ProfileProperties_TrafficRoutingMethod_Subnet      = ProfileProperties_TrafficRoutingMethod("Subnet")
	ProfileProperties_TrafficRoutingMethod_Weighted    = ProfileProperties_TrafficRoutingMethod("Weighted")
)

type ProfileProperties_TrafficRoutingMethod_STATUS string

const (
	ProfileProperties_TrafficRoutingMethod_STATUS_Geographic  = ProfileProperties_TrafficRoutingMethod_STATUS("Geographic")
	ProfileProperties_TrafficRoutingMethod_STATUS_MultiValue  = ProfileProperties_TrafficRoutingMethod_STATUS("MultiValue")
	ProfileProperties_TrafficRoutingMethod_STATUS_Performance = ProfileProperties_TrafficRoutingMethod_STATUS("Performance")
	ProfileProperties_TrafficRoutingMethod_STATUS_Priority    = ProfileProperties_TrafficRoutingMethod_STATUS("Priority")
	ProfileProperties_TrafficRoutingMethod_STATUS_Subnet      = ProfileProperties_TrafficRoutingMethod_STATUS("Subnet")
	ProfileProperties_TrafficRoutingMethod_STATUS_Weighted    = ProfileProperties_TrafficRoutingMethod_STATUS("Weighted")
)

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ProfileProperties_TrafficViewEnrollmentStatus string

const (
	ProfileProperties_TrafficViewEnrollmentStatus_Disabled = ProfileProperties_TrafficViewEnrollmentStatus("Disabled")
	ProfileProperties_TrafficViewEnrollmentStatus_Enabled  = ProfileProperties_TrafficViewEnrollmentStatus("Enabled")
)

type ProfileProperties_TrafficViewEnrollmentStatus_STATUS string

const (
	ProfileProperties_TrafficViewEnrollmentStatus_STATUS_Disabled = ProfileProperties_TrafficViewEnrollmentStatus_STATUS("Disabled")
	ProfileProperties_TrafficViewEnrollmentStatus_STATUS_Enabled  = ProfileProperties_TrafficViewEnrollmentStatus_STATUS("Enabled")
)

type MonitorConfig_CustomHeaders struct {
	// Name: Header name.
	Name *string `json:"name,omitempty"`

	// Value: Header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &MonitorConfig_CustomHeaders{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (headers *MonitorConfig_CustomHeaders) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if headers == nil {
		return nil, nil
	}
	result := &MonitorConfig_CustomHeaders_ARM{}

	// Set property ‘Name’:
	if headers.Name != nil {
		name := *headers.Name
		result.Name = &name
	}

	// Set property ‘Value’:
	if headers.Value != nil {
		value := *headers.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (headers *MonitorConfig_CustomHeaders) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MonitorConfig_CustomHeaders_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (headers *MonitorConfig_CustomHeaders) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MonitorConfig_CustomHeaders_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MonitorConfig_CustomHeaders_ARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		headers.Name = &name
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		headers.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig_CustomHeaders populates our MonitorConfig_CustomHeaders from the provided source MonitorConfig_CustomHeaders
func (headers *MonitorConfig_CustomHeaders) AssignProperties_From_MonitorConfig_CustomHeaders(source *v20180801s.MonitorConfig_CustomHeaders) error {

	// Name
	headers.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	headers.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig_CustomHeaders populates the provided destination MonitorConfig_CustomHeaders from our MonitorConfig_CustomHeaders
func (headers *MonitorConfig_CustomHeaders) AssignProperties_To_MonitorConfig_CustomHeaders(destination *v20180801s.MonitorConfig_CustomHeaders) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(headers.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(headers.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type MonitorConfig_CustomHeaders_STATUS struct {
	// Name: Header name.
	Name *string `json:"name,omitempty"`

	// Value: Header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &MonitorConfig_CustomHeaders_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (headers *MonitorConfig_CustomHeaders_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MonitorConfig_CustomHeaders_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (headers *MonitorConfig_CustomHeaders_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MonitorConfig_CustomHeaders_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MonitorConfig_CustomHeaders_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		headers.Name = &name
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		headers.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig_CustomHeaders_STATUS populates our MonitorConfig_CustomHeaders_STATUS from the provided source MonitorConfig_CustomHeaders_STATUS
func (headers *MonitorConfig_CustomHeaders_STATUS) AssignProperties_From_MonitorConfig_CustomHeaders_STATUS(source *v20180801s.MonitorConfig_CustomHeaders_STATUS) error {

	// Name
	headers.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	headers.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig_CustomHeaders_STATUS populates the provided destination MonitorConfig_CustomHeaders_STATUS from our MonitorConfig_CustomHeaders_STATUS
func (headers *MonitorConfig_CustomHeaders_STATUS) AssignProperties_To_MonitorConfig_CustomHeaders_STATUS(destination *v20180801s.MonitorConfig_CustomHeaders_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(headers.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(headers.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type MonitorConfig_ExpectedStatusCodeRanges struct {
	// Max: Max status code.
	Max *int `json:"max,omitempty"`

	// Min: Min status code.
	Min *int `json:"min,omitempty"`
}

var _ genruntime.ARMTransformer = &MonitorConfig_ExpectedStatusCodeRanges{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ranges *MonitorConfig_ExpectedStatusCodeRanges) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ranges == nil {
		return nil, nil
	}
	result := &MonitorConfig_ExpectedStatusCodeRanges_ARM{}

	// Set property ‘Max’:
	if ranges.Max != nil {
		max := *ranges.Max
		result.Max = &max
	}

	// Set property ‘Min’:
	if ranges.Min != nil {
		min := *ranges.Min
		result.Min = &min
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ranges *MonitorConfig_ExpectedStatusCodeRanges) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MonitorConfig_ExpectedStatusCodeRanges_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ranges *MonitorConfig_ExpectedStatusCodeRanges) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MonitorConfig_ExpectedStatusCodeRanges_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MonitorConfig_ExpectedStatusCodeRanges_ARM, got %T", armInput)
	}

	// Set property ‘Max’:
	if typedInput.Max != nil {
		max := *typedInput.Max
		ranges.Max = &max
	}

	// Set property ‘Min’:
	if typedInput.Min != nil {
		min := *typedInput.Min
		ranges.Min = &min
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges populates our MonitorConfig_ExpectedStatusCodeRanges from the provided source MonitorConfig_ExpectedStatusCodeRanges
func (ranges *MonitorConfig_ExpectedStatusCodeRanges) AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges(source *v20180801s.MonitorConfig_ExpectedStatusCodeRanges) error {

	// Max
	ranges.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	ranges.Min = genruntime.ClonePointerToInt(source.Min)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges populates the provided destination MonitorConfig_ExpectedStatusCodeRanges from our MonitorConfig_ExpectedStatusCodeRanges
func (ranges *MonitorConfig_ExpectedStatusCodeRanges) AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges(destination *v20180801s.MonitorConfig_ExpectedStatusCodeRanges) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Max
	destination.Max = genruntime.ClonePointerToInt(ranges.Max)

	// Min
	destination.Min = genruntime.ClonePointerToInt(ranges.Min)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type MonitorConfig_ExpectedStatusCodeRanges_STATUS struct {
	// Max: Max status code.
	Max *int `json:"max,omitempty"`

	// Min: Min status code.
	Min *int `json:"min,omitempty"`
}

var _ genruntime.FromARMConverter = &MonitorConfig_ExpectedStatusCodeRanges_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ranges *MonitorConfig_ExpectedStatusCodeRanges_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MonitorConfig_ExpectedStatusCodeRanges_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ranges *MonitorConfig_ExpectedStatusCodeRanges_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MonitorConfig_ExpectedStatusCodeRanges_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MonitorConfig_ExpectedStatusCodeRanges_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Max’:
	if typedInput.Max != nil {
		max := *typedInput.Max
		ranges.Max = &max
	}

	// Set property ‘Min’:
	if typedInput.Min != nil {
		min := *typedInput.Min
		ranges.Min = &min
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges_STATUS populates our MonitorConfig_ExpectedStatusCodeRanges_STATUS from the provided source MonitorConfig_ExpectedStatusCodeRanges_STATUS
func (ranges *MonitorConfig_ExpectedStatusCodeRanges_STATUS) AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges_STATUS(source *v20180801s.MonitorConfig_ExpectedStatusCodeRanges_STATUS) error {

	// Max
	ranges.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	ranges.Min = genruntime.ClonePointerToInt(source.Min)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges_STATUS populates the provided destination MonitorConfig_ExpectedStatusCodeRanges_STATUS from our MonitorConfig_ExpectedStatusCodeRanges_STATUS
func (ranges *MonitorConfig_ExpectedStatusCodeRanges_STATUS) AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges_STATUS(destination *v20180801s.MonitorConfig_ExpectedStatusCodeRanges_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Max
	destination.Max = genruntime.ClonePointerToInt(ranges.Max)

	// Min
	destination.Min = genruntime.ClonePointerToInt(ranges.Min)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"CheckingEndpoints","Degraded","Disabled","Inactive","Online"}
type MonitorConfig_ProfileMonitorStatus string

const (
	MonitorConfig_ProfileMonitorStatus_CheckingEndpoints = MonitorConfig_ProfileMonitorStatus("CheckingEndpoints")
	MonitorConfig_ProfileMonitorStatus_Degraded          = MonitorConfig_ProfileMonitorStatus("Degraded")
	MonitorConfig_ProfileMonitorStatus_Disabled          = MonitorConfig_ProfileMonitorStatus("Disabled")
	MonitorConfig_ProfileMonitorStatus_Inactive          = MonitorConfig_ProfileMonitorStatus("Inactive")
	MonitorConfig_ProfileMonitorStatus_Online            = MonitorConfig_ProfileMonitorStatus("Online")
)

type MonitorConfig_ProfileMonitorStatus_STATUS string

const (
	MonitorConfig_ProfileMonitorStatus_STATUS_CheckingEndpoints = MonitorConfig_ProfileMonitorStatus_STATUS("CheckingEndpoints")
	MonitorConfig_ProfileMonitorStatus_STATUS_Degraded          = MonitorConfig_ProfileMonitorStatus_STATUS("Degraded")
	MonitorConfig_ProfileMonitorStatus_STATUS_Disabled          = MonitorConfig_ProfileMonitorStatus_STATUS("Disabled")
	MonitorConfig_ProfileMonitorStatus_STATUS_Inactive          = MonitorConfig_ProfileMonitorStatus_STATUS("Inactive")
	MonitorConfig_ProfileMonitorStatus_STATUS_Online            = MonitorConfig_ProfileMonitorStatus_STATUS("Online")
)

// +kubebuilder:validation:Enum={"HTTP","HTTPS","TCP"}
type MonitorConfig_Protocol string

const (
	MonitorConfig_Protocol_HTTP  = MonitorConfig_Protocol("HTTP")
	MonitorConfig_Protocol_HTTPS = MonitorConfig_Protocol("HTTPS")
	MonitorConfig_Protocol_TCP   = MonitorConfig_Protocol("TCP")
)

type MonitorConfig_Protocol_STATUS string

const (
	MonitorConfig_Protocol_STATUS_HTTP  = MonitorConfig_Protocol_STATUS("HTTP")
	MonitorConfig_Protocol_STATUS_HTTPS = MonitorConfig_Protocol_STATUS("HTTPS")
	MonitorConfig_Protocol_STATUS_TCP   = MonitorConfig_Protocol_STATUS("TCP")
)

func init() {
	SchemeBuilder.Register(&Trafficmanagerprofile{}, &TrafficmanagerprofileList{})
}
